Index: .idea/copyright/profiles_settings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/copyright/profiles_settings.xml	(revision )
+++ .idea/copyright/profiles_settings.xml	(revision )
@@ -0,0 +1,3 @@
+<component name="CopyrightManager">
+  <settings default="" />
+</component>
\ No newline at end of file
Index: src/gameRecord/RecordTankActions.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/gameRecord/RecordTankActions.java	(revision )
+++ src/gameRecord/RecordTankActions.java	(revision )
@@ -0,0 +1,66 @@
+package gameRecord;
+
+import tanks.Action;
+import tanks.Direction;
+
+import java.io.*;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by Byblik272 on 14/2/2016.
+ */
+public class RecordTankActions implements FileOfRecord {
+
+    @Override
+    public synchronized void write(String s, ObjectOutputStream oos, Direction direction, Action action) {
+        try {
+            oos.writeObject(s);
+            oos.writeObject(direction);
+            oos.writeObject(action);
+            oos.flush();
+        } catch (Exception e) {
+            // ignore
+        }
+    }
+    @Override
+    public List read(String fileName) {
+        List list = new ArrayList();
+        try {
+            FileInputStream fis = new FileInputStream(fileName);
+            BufferedInputStream bis = new BufferedInputStream(fis);
+            ObjectInputStream ois = new ObjectInputStream(bis);
+
+            int mapLevel = (int) ois.readObject();
+            list.add(mapLevel);
+            int firstAggressorIdx = (int) ois.readObject();
+            list.add(firstAggressorIdx);
+            int secondAggressorIdx = (int) ois.readObject();
+            list.add(secondAggressorIdx);
+
+            while (bis.available() > 0) {
+                String crewName = (String) ois.readObject();
+                list.add(crewName);
+                Direction direction = (Direction) ois.readObject();
+                list.add(direction);
+                Action action = (Action) ois.readObject();
+                list.add(action);
+            }
+
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return list;
+    }
+
+    public void writeGameData(ObjectOutputStream oos, int mapLevel, int firstAggressorIdx, int secondAggressorIdx) {
+        try {
+            oos.writeObject(mapLevel);
+            oos.writeObject(firstAggressorIdx);
+            oos.writeObject(secondAggressorIdx);
+            oos.flush();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
Index: src/tanks/T34.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/tanks/T34.java	(revision )
+++ src/tanks/T34.java	(revision )
@@ -0,0 +1,35 @@
+package tanks;
+
+
+import objectsOnField.BattleField;
+
+import java.awt.*;
+import java.util.List;
+
+/**
+ * Created by Byblik272 on 18/11/2015.
+ */
+public class T34 extends AbstractTank {
+
+    public T34(BattleField bf, int x, int y, Direction direction, Image image, String crewName) {
+        super(bf, x, y, direction, image, true, crewName);
+        tankColor = new Color(0, 0, 255);
+        towerColor = new Color(255, 0, 0);
+        setImage();
+
+    }
+
+    private void setImage() {
+        images = new Image[4];
+
+        for(int i = 0; i < images.length; i++) {
+            images[i] = createImage(image, 64 * (i + 4), 0, 64, 64);
+        }
+    }
+
+    @Override
+    public Action setUp(List<Tank> tankList) {
+
+        return getAction();
+    }
+}
Index: src/tanks/Tiger.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/tanks/Tiger.java	(revision )
+++ src/tanks/Tiger.java	(revision )
@@ -0,0 +1,50 @@
+package tanks;
+
+
+import objectsOnField.BattleField;
+
+import java.awt.*;
+import java.util.List;
+
+/**
+ * Created by Byblik272 on 18/11/2015.
+ */
+
+public class Tiger extends AbstractTank {
+
+    private int armor;
+
+    public Tiger(BattleField bf, int x, int y, Direction direction, Image image, Tank opponent, boolean player, String crewName) {
+        super(bf, x, y, direction, image, player, crewName);
+        tankColor = new Color(255, 0, 0);
+        towerColor = new Color(0, 0, 0);
+        armor = 1;
+        tankOpponent = opponent;
+        setImage();
+    }
+    private void setImage() {
+        images = new Image[4];
+
+        for(int i = 0; i < images.length; i++) {
+            images[i] = createImage(image, 64 * i, 64, 64, 64);
+        }
+    }
+
+    @Override
+    public void destroy() {
+        if (armor > 0) {
+            armor--;
+        } else {
+            super.destroy();
+        }
+    }
+
+    @Override
+    public Action setUp(List<Tank> tankList) {
+        if(player) {
+            return getAction();
+        } else {
+            return destroyOpponent(tankOpponent);
+        }
+    }
+}
Index: RunnableGame/readme.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-16LE
===================================================================
--- RunnableGame/readme.txt	(revision )
+++ RunnableGame/readme.txt	(revision )
@@ -0,0 +1,57 @@
+					----------Игра Танки----------
+				   
+				   		   Правила
+
+Игроку предстоит играть за защитника(танк Т34) штаба(Орел) против двух атакующих. 
+Возможность выбирать для атакующих из танков Tiger и BT7 для каждого соответственно.
+Задача танка Tiger - находить и уничтожать защитника.
+Задача танка BT7 - уничтожить штаб. 
+Поддержка двух режимов игры: против компьютера или против копьютера и человека.
+Возможность выбора поля боя из нескольких вариантов.
+Запуск игры начинается при нажатии на кнопку "Go Game".
+Доступна возможность паузы во время игры и записи.
+Во время игры осуществляется запись игры в файл "GameRecord.txt". 
+После игры есть возможность посмотреть запись последней игры.
+Если последней игры еще не было, кнопка "Show the last game record" изменит надпись на "Currently record doesn`t exist".
+При завершении игры появляется меню выбора.
+Кнопка("Play Again") - играть заново, кнопка("Exit") - выход.  
+
+					----------Управление----------
+
+			Клавиша(P) - пауза / возобновление.
+
+Если при нажатии клавиши направления, она совпадает с направлением движения танка, он поедет, если нет - развернется.
+Перезарядка выстрела - одна секунда.
+
+				   Защитник
+
+			Клавиша(А) - движение влево.
+			Клавиша(D) - движение вправо.
+			Клавиша(W) - движение вверх.
+			Клавиша(S) - движение вниз.
+			Клавиша(Space) - стрелять.
+
+				  Атакующий
+
+			Клавиша(J) - движение влево.
+			Клавиша(L) - движение вправо.
+			Клавиша(I) - движение вверх.
+			Клавиша(K) - движение вниз.
+			Клавиша(N) - стрелять.
+
+
+					----------Ребус для программистов----------
+
+List mapLis = new ArrayList();
+
+mapLis.add(map1);
+mapLis.add(map2);
+mapLis.add(map3);
+mapLis.add(map4);
+
+System.out.print("Special thanks to ");
+
+for(Map map : MapList) { System.out.print(map.Entry); }
+
+
+ 
\ No newline at end of file
Index: src/objectsOnField/Eagle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/objectsOnField/Eagle.java	(revision )
+++ src/objectsOnField/Eagle.java	(revision )
@@ -0,0 +1,14 @@
+package objectsOnField;
+
+import java.awt.*;
+
+/**
+ * Created by Byblik272 on 2/12/2015.
+ */
+public class Eagle extends AbstractObjectOnField {
+
+    public Eagle(int x, int y, Image image) {
+        super(x, y, image);
+        numberInQueue = 7;
+    }
+}
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/modules.xml	(revision )
+++ .idea/modules.xml	(revision )
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/TanksGame.iml" filepath="$PROJECT_DIR$/TanksGame.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: src/action/ActionField.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/action/ActionField.java	(revision )
+++ src/action/ActionField.java	(revision )
@@ -0,0 +1,756 @@
+package action;
+
+import gameRecord.RecordTankActions;
+import objectsOnField.*;
+import objectsOnField.Void;
+import tanks.*;
+import tanks.Action;
+
+import javax.imageio.ImageIO;
+import javax.swing.*;
+import java.awt.*;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.KeyAdapter;
+import java.awt.event.KeyEvent;
+import java.io.*;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ConcurrentSkipListSet;
+
+public class ActionField {
+
+    volatile private ConcurrentSkipListSet<Character> pressed = new ConcurrentSkipListSet<>();
+    private static BattleField battleField;
+    private Tank defender;
+    private Tank firstAggressor;
+    private Tank secondAggressor;
+    private volatile boolean play = true;
+    private JFrame frame;
+    private int firstAggressorIdx;
+    private int secondAggressorIdx;
+    private int mapLevel;
+
+    private List defenderActionsFromRecord;
+    private List firstAggressorActionsFromRecord;
+    private List secondAggressorActionsFromRecord;
+    private List tanksActions;
+
+    private String firstAggressorLocation;
+    private int firstAggressorLocationX;
+    private int firstAggressorLocationY;
+
+    private String secondAggressorLocation;
+    private int secondAggressorLocationX;
+    private int secondAggressorLocationY;
+
+    private String defenderLocation;
+    private int defenderLocationX;
+    private int defenderLocationY;
+
+    private boolean firstAggressorPlayer;
+    private boolean secondAggressorPlayer;
+
+    boolean notReplay = true;
+    private AbstractObjectOnField eagle;
+
+    private String imageName = "/image/ImageForObjects.png";
+    private String fileName = "/GameRecord.txt";
+
+    private FileOutputStream fos;
+    private ObjectOutputStream oos;
+    private RecordTankActions recordActions;
+    private List recordList;
+    private int ifBrokeRecord;
+    private List<Bullet> bullets;
+
+    private Image image;
+    private List<Tank> tanksList;
+
+    private Thread paint() {
+        return new Thread(new Runnable() {
+            @Override
+            public void run() {
+                while (isGameEnd() && ifBrokeRecord != tanksList.size()) {
+                    frame.repaint();
+                    sleep(1000 / 60);
+                }
+                for(int i = 0; i < 60; i++) {
+                    frame.repaint();
+                    sleep(1000 / 60);
+                }
+                try {
+                    if(oos != null) {
+                        oos.close();
+                    }
+                } catch (IOException e) {
+                    // ignore
+                }
+                closeOrRepeat();
+            }
+        });
+    }
+    private void runTheGame() {
+        for(Tank tank : tanksList) {
+           tankGameThread(tank).start();
+        }
+    }
+
+    private void runTheRecordGame() {
+        for(int i = 0; i < tanksList.size(); i++) {
+            tankRecordGameThread(tanksList.get(i), i).start();
+        }
+    }
+
+    private boolean isGameEnd() {
+        if((!firstAggressor.isDestroyed() || !secondAggressor.isDestroyed()) && !defender.isDestroyed() && !eagle.isDestroyed()) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private Thread tankRecordGameThread(final Tank tank, final  int i) {
+        return new Thread(new Runnable() {
+            @Override
+            public void run() {
+                List list = (List) tanksActions.get(i);
+                int j;
+                for(int i = 0; i < list.size(); i++) {
+                    j = 0;
+                    while (j < 1) {
+                        if(play) {
+                            tank.setDirection((Direction) list.get(i++));
+                            recordProcessAction((Action) list.get(i), tank);
+                            sleep(10);
+                            j++;
+                        } else {
+                            tank.holdRecharge(500);
+                            sleep(500);
+                        }
+                    }
+                }
+                ifBrokeRecord++;
+            }
+        });
+
+    }
+    private Thread tankGameThread(final Tank tank) {
+        Thread thread = new Thread(new Runnable() {
+            @Override
+            public void run() {
+                while (isGameEnd() && !tank.isDestroyed()) {
+
+                    if(play) {
+                        processAction(tank.setUp(tanksList), tank);
+                        sleep(10);
+                    } else {
+                        tank.holdRecharge(500);
+                        sleep(500);
+                    }
+                }
+            }
+        });
+        return thread;
+    }
+
+    private void recordProcessAction(Action a, Tank t) {
+        if(a == Action.MOVE) {
+            processMove(t);
+        } else if(a == Action.FIRE && t.isRecharge()) {
+            processFire(t.fire());
+        }
+    }
+
+    private void processAction(Action a, Tank t) {
+        if (a == Action.MOVE) {
+            processMove(t);
+        } else if (a == Action.FIRE && t.isRecharge()) {
+            processFire(t.fire());
+        }
+
+        t.setPlayerAction(Action.NONE);
+
+        recordActions.write(t.getCrewName(), oos, t.getDirection(), a);
+    }
+
+
+    public void processMove(Tank tank) {
+        Direction direction = tank.getDirection();
+
+        String tankQuadrant = getQuadrant(tank.getX(), tank.getY());
+        int v = Integer.parseInt(tankQuadrant.split("_")[0]);
+        int h = Integer.parseInt(tankQuadrant.split("_")[1]);
+
+        if (direction == Direction.UP) {
+            v--;
+        } else if (direction == Direction.DOWN) {
+            v++;
+        } else if (direction == Direction.RIGHT) {
+            h++;
+        } else if (direction == Direction.LEFT) {
+            h--;
+        }
+
+        if(checkTank(tank, v, h)) {
+            return;
+        }
+
+        if (checkLimits(direction, tank)) {
+            return;
+        }
+
+        if(checkNextQuadrant(v, h)) {
+            return;
+        }
+
+        int i = 0;
+        int step = 1;
+        while (i < 64) {
+            if(play) {
+                if (direction == Direction.UP) {
+                    tank.updateY(-step);
+
+                } else if (direction == Direction.DOWN) {
+                    tank.updateY(step);
+
+                } else if (direction == Direction.LEFT) {
+                    tank.updateX(-step);
+
+                } else if (direction == Direction.RIGHT) {
+                    tank.updateX(step);
+                }
+
+                i += step;
+                sleep(tank.getSpeed());
+            } else {
+                sleep(500);
+            }
+        }
+    }
+    private boolean checkLimits(Direction direction, Tank tank) {
+        if ((direction == Direction.UP && tank.getY() == battleField.getMinRiftField())
+                || (direction == Direction.DOWN && tank.getY() >= battleField.getMaxRiftField())
+                || (direction == Direction.LEFT && tank.getX() == battleField.getMinRiftField())
+                || (direction == Direction.RIGHT && tank.getX() >= battleField.getMaxRiftField())) {
+            return true;
+        } else return false;
+    }
+
+    private boolean checkTank(Tank tank, int y, int x) {
+        for(Tank t : tanksList) {
+            if(tank != t && Math.abs(x * battleField.getLimitQuadrant() - t.getX()) < 64 && Math.abs(y * battleField.getLimitQuadrant() - t.getY()) < 64 && !t.isDestroyed()){
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean checkNextQuadrant(int v, int h) {
+        AbstractObjectOnField abstractObjectOnField = battleField.scanQuadrant(v, h);
+        if (!(abstractObjectOnField instanceof Void) && !abstractObjectOnField.isDestroyed()) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public void processFire(final Bullet bullet) {
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                bullets.add(bullet);
+                int step = 1;
+                int bodyX = bullet.getX();
+                int bodyY = bullet.getY();
+                while (bullet.getX() < 590 && bullet.getX() > -14 &&
+                        bullet.getY() < 590 && bullet.getY() > -14) {
+                    if(play) {
+                        if (bullet.getDirection() == Direction.UP) {
+                            bullet.updateY(-step);
+                            bodyY = bullet.getY();
+                        } else if (bullet.getDirection() == Direction.DOWN) {
+                            bullet.updateY(step);
+                            bodyY = bullet.getY() + 14;
+
+                        } else if (bullet.getDirection() == Direction.LEFT) {
+                            bullet.updateX(-step);
+                            bodyX = bullet.getX();
+
+                        } else {
+                            bullet.updateX(step);
+                            bodyX = bullet.getX() + 14;
+                        }
+
+                        if (processInterception(bullet, bodyX, bodyY)) {
+                            break;
+                        }
+                        sleep(bullet.getSpeed());
+                    } else {
+                        sleep(500);
+                    }
+                }
+                bullets.remove(bullet);
+            }
+        }).start();
+    }
+
+    private boolean processInterception(Bullet bullet, int bodyX, int bodyY) {
+        for(int i = 0; i < bullets.size(); i++) {
+
+                if(bullet != bullets.get(i) && Math.abs(bullet.getX() - bullets.get(i).getX()) < 14 && Math.abs(bullet.getY() - bullets.get(i).getY()) < 14) {
+                    try {
+                        bullet.destroy();
+                        bullets.get(i).destroy();
+                        return true;
+                    } finally {
+                        bullets.get(i).destroy();
+                        bullet.destroy();
+                        return true;
+                    }
+                }
+
+        }
+
+        int x = bodyX / battleField.getLimitQuadrant();
+        int y = bodyY / battleField.getLimitQuadrant();
+
+        if (x >= 0 && x < 9 && y >= 0 && y < 9) {
+            AbstractObjectOnField abstractObjectOnField = battleField.scanQuadrant(y, x);
+            if(bullet.getTank() instanceof Tiger) {
+                if (!abstractObjectOnField.isDestroyed() && !(abstractObjectOnField instanceof Void) && !(abstractObjectOnField instanceof Water)) {
+                    battleField.destroyObject(y, x);
+                    bullet.destroy();
+                    return true;
+                }
+            }else  {
+                if (!abstractObjectOnField.isDestroyed() && !(abstractObjectOnField instanceof Void) && !(abstractObjectOnField instanceof Water)) {
+                    if(abstractObjectOnField instanceof Rock) {
+                        bullet.destroy();
+                        return true;
+                    }else {
+                        battleField.destroyObject(y, x);
+                        bullet.destroy();
+                        return true;
+                    }
+                }
+            }
+        }
+
+        for(Tank tank : tanksList) {
+            if(!tank.isDestroyed() && Math.abs((bullet.getX() + 7) - (tank.getX() + 32)) < 39 &&
+                    Math.abs((bullet.getY() + 7) - (tank.getY() + 32)) < 39 && !bullet.getCrewName().substring(0, 1).equals(tank.getCrewName().substring(0, 1))) {
+                tank.destroy();
+                bullet.destroy();
+                return true;
+            }
+        }
+        return false;
+    }
+
+    String getQuadrant(int x, int y) {
+        return y / battleField.getLimitQuadrant() + "_" + x / battleField.getLimitQuadrant();
+    }
+
+    public ActionField() throws Exception {
+        try {
+            image = ImageIO.read(getClass().getResource(imageName));
+        } catch (IOException e) {
+            System.out.println("Image not found");
+        }
+        battleField = new BattleField(image, mapLevel);
+
+        gameOptions();
+        frame = new JFrame("BATTLE FIELD, DAY 2");
+        frame.setLocation(500, 150);
+        frame.setMinimumSize(new Dimension(battleField.getBF_WIDTH(), battleField.getBF_HEIGHT()));
+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
+        frame.getContentPane().add(gameOptions());
+        frame.setVisible(true);
+        frame.pack();
+
+        frame.addKeyListener(new KeyAdapter() {
+
+            @Override
+            public void keyTyped(KeyEvent e) {
+                pressedButtons(e.getKeyChar());
+            }
+
+            @Override
+            public synchronized void keyPressed(KeyEvent e) {
+                pressed.add(e.getKeyChar());
+
+            }
+
+            @Override
+            public synchronized void keyReleased(KeyEvent e) {
+                pressed.remove(e.getKeyChar());
+            }
+
+        });
+    }
+
+    private void drawBullets(Graphics g) {
+        try{
+            for (Bullet bullet : bullets) {
+                bullet.draw(g);
+            }
+        } catch (Exception e) {
+            // ignore
+        }
+    }
+
+    private void pressedButtons(Character button) {
+        if(button == 'p') {
+            play = !play;
+        }
+            if (button == 'a') {
+                defender.setPlayerAction(Action.LEFT);
+            } else if (button == 'd') {
+                defender.setPlayerAction(Action.RIGHT);
+            } else if (button == 'w') {
+                defender.setPlayerAction(Action.UP);
+            } else if (button == 's') {
+                defender.setPlayerAction(Action.DOWN);
+            } else if (button == ' ') {
+                defender.setPlayerAction(Action.FIRE);
+            } else if (button == 'j') {
+                firstAggressor.setPlayerAction(Action.LEFT);
+            } else if (button == 'l') {
+                firstAggressor.setPlayerAction(Action.RIGHT);
+            } else if (button == 'i') {
+                firstAggressor.setPlayerAction(Action.UP);
+            } else if (button == 'k') {
+                firstAggressor.setPlayerAction(Action.DOWN);
+            } else if (button == 'n') {
+                firstAggressor.setPlayerAction(Action.FIRE);
+            }
+    }
+    private JPanel gamePanel() {
+        JPanel jGame = new JPanel()
+        {
+            @Override
+            protected void paintComponent(Graphics g) {
+                super.paintComponent(g);
+                battleField.draw(g);
+                for (Tank tank : tanksList) {
+                    tank.draw(g);
+                }
+                drawBullets(g);
+                battleField.drawShrubs(g);
+                sleep(1000 / 60);
+            }
+        };
+        frame.setFocusable(false);
+        paint().start();
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                while (isGameEnd()) {
+                    if(pressed.size() > 0) {
+                        sleep(200);
+                        for(Character key : pressed) {
+                            pressedButtons(key);
+                        }
+                    }
+                }
+            }
+        }).start();
+        return jGame;
+    }
+
+    private void actionsFromRecordList() {
+        defenderActionsFromRecord = new ArrayList();
+        firstAggressorActionsFromRecord = new ArrayList();
+        secondAggressorActionsFromRecord = new ArrayList();
+        tanksActions = new ArrayList();
+        for(int i = 3; i < recordList.size();i++) {
+            if (defender.getCrewName().equals(recordList.get(i))) {
+                defenderActionsFromRecord.add(recordList.get(++i));
+                defenderActionsFromRecord.add(recordList.get(++i));
+            } else
+                if(firstAggressor.getCrewName().equals(recordList.get(i))) {
+                    firstAggressorActionsFromRecord.add(recordList.get(++i));
+                    firstAggressorActionsFromRecord.add(recordList.get(++i));
+                } else
+                    if(secondAggressor.getCrewName().equals(recordList.get(i))) {
+                        secondAggressorActionsFromRecord.add(recordList.get(++i));
+                        secondAggressorActionsFromRecord.add(recordList.get(++i));
+                    }
+        }
+        tanksActions.add(defenderActionsFromRecord);
+        tanksActions.add(firstAggressorActionsFromRecord);
+        tanksActions.add(secondAggressorActionsFromRecord);
+    }
+    private JPanel gameOver() {
+        ifBrokeRecord = 0;
+        frame.setFocusable(false);
+        JPanel gameOver = new JPanel();
+        gameOver.setLayout(new GridBagLayout());
+        JLabel resultGame;
+        if(defender.isDestroyed() || eagle.isDestroyed()) {
+            resultGame = new JLabel("You Lose!");
+        } else {
+            resultGame = new JLabel("You Win!");
+        }
+        JButton goAgain = new JButton("Play Again");
+        goAgain.setForeground(Color.BLACK);
+        goAgain.setBackground(new Color(100, 255, 100));
+
+        JButton record = new JButton("Show the game record");
+        record.setForeground(Color.BLACK);
+        record.setBackground(new Color(100, 255, 100));
+
+        final JButton goOut = new JButton("Exit");
+        goOut.setForeground(Color.BLACK);
+        goOut.setBackground(new Color(100, 255, 100));
+
+        gameOver.add(resultGame);
+        gameOver.add(goAgain);
+        gameOver.add(goOut);
+
+        goAgain.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                gameResult();
+            }
+        });
+        goOut.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                frame.setVisible(false);
+                System.exit(0);
+            }
+        });
+
+        return gameOver;
+    }
+
+    private JPanel gameOptions() {
+        firstAggressorIdx = 0;
+        secondAggressorIdx = 1;
+        mapLevel = 0;
+        firstAggressorPlayer = false;
+        recordList = new ArrayList();
+        recordActions = new RecordTankActions();
+        ifBrokeRecord = 0;
+        JPanel jTankChoose = new JPanel();
+        jTankChoose.setLayout(new GridBagLayout());
+        JLabel firstAggressorTank = new JLabel("Choose   First  Aggressor   Tank  : ");
+
+        ButtonGroup firstButtonGroup = new ButtonGroup();
+        JPanel firstPanelTanks = new JPanel();
+        ActionListener firstRbListener = new RBListener(0);
+        String[] tanks = {"BT7", "Tiger"};
+        for(int i = 0; i < tanks.length; i++) {
+            JRadioButton radioButton = new JRadioButton(tanks[i]);
+            radioButton.setActionCommand(String.valueOf(i));
+            radioButton.addActionListener(firstRbListener);
+            if(i == 0) {
+                radioButton.setSelected(true);
+            }
+            firstButtonGroup.add(radioButton);
+            firstPanelTanks.add(radioButton);
+        }
+        ButtonGroup secondButtonGroup = new ButtonGroup();
+        JPanel secondPanelTanks = new JPanel();
+        JLabel secondAggressorTank = new JLabel("Choose Second Aggressor Tank : ");
+        ActionListener secondRbListener = new RBListener(1);
+        for(int i = 1; i >= 0; i--) {
+            JRadioButton radioButton = new JRadioButton(tanks[i]);
+            radioButton.setActionCommand(String.valueOf(i));
+            radioButton.addActionListener(secondRbListener);
+            if(i == 1) {
+                radioButton.setSelected(true);
+            }
+            secondButtonGroup.add(radioButton);
+            secondPanelTanks.add(radioButton);
+        }
+        firstPanelTanks.setLayout(new GridLayout(tanks.length / 2, 0, 0, 0));
+        firstPanelTanks.setBorder(BorderFactory.createLineBorder(Color.GREEN));
+
+        secondPanelTanks.setLayout(new GridLayout(tanks.length / 2, 0, 0, 0));
+        secondPanelTanks.setBorder(BorderFactory.createLineBorder(Color.GREEN));
+
+        JLabel aggressorsPlayingLabel = new JLabel("Who Plays For The Aggressors :");
+        final JComboBox aggressorsPlayers = new JComboBox();
+        aggressorsPlayers.addItem("Computers");
+        aggressorsPlayers.addItem("Player and Computer");
+        aggressorsPlayers.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                if(aggressorsPlayers.getSelectedIndex() == 0) {
+                    firstAggressorPlayer = false;
+                } else {
+                    firstAggressorPlayer = true;
+                }
+            }
+        });
+
+        final JLabel battleFieldLevel = new JLabel("Choose  Battle  Field  Game  Map : ");
+        final JComboBox mapListBox = new JComboBox();
+        for(int i = 0; i < battleField.getMapListSize(); i++) {
+            mapListBox.addItem("Map" + (i + 1));
+        }
+        mapListBox.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                mapLevel = mapListBox.getSelectedIndex();
+            }
+        });
+        JButton goGame = new JButton("Go Game");
+        goGame.setForeground(Color.BLACK);
+        goGame.setBackground(new Color(100, 255, 100));
+
+        final JButton record = new JButton("Show  the   last   game  record");
+        record.setForeground(Color.BLACK);
+        record.setBackground(new Color(100, 255, 100));
+
+        record.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                notReplay = false;
+                frame.setFocusable(true);
+                File file = new File(fileName);
+                if(file.exists()) {
+                    recordList = recordActions.read(fileName);
+                    mapLevel = (int) recordList.get(0);
+                    firstAggressorIdx = (int) recordList.get(1);
+                    secondAggressorIdx = (int) recordList.get(2);
+                    firstAggressorPlayer = false;
+                    selectObjects();
+                    drawBF();
+                    actionsFromRecordList();
+                    runTheRecordGame();
+                } else {
+                    record.setText("Currently record doesn`t exist");
+                }
+            }
+        });
+
+        jTankChoose.add(firstAggressorTank, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.LINE_START, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
+        jTankChoose.add(firstPanelTanks, new GridBagConstraints(1, 0, 1, 1, 0, 0, GridBagConstraints.LINE_START, 0, new Insets(0, 0, 0, 0), 0, 0));
+
+        jTankChoose.add(secondAggressorTank, new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.LINE_START, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
+        jTankChoose.add(secondPanelTanks, new GridBagConstraints(1, 1, 1, 1, 0, 0, GridBagConstraints.LINE_START, 0, new Insets(0, 0, 0, 0), 0, 0));
+
+        jTankChoose.add(aggressorsPlayingLabel, new GridBagConstraints(0, 2, 1, 1, 0, 0, GridBagConstraints.LINE_START, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
+        jTankChoose.add(aggressorsPlayers, new GridBagConstraints(1, 2, 1, 1, 0, 0, GridBagConstraints.LINE_START, 0, new Insets(0, 0, 0, 0), 0, 0));
+
+        jTankChoose.add(battleFieldLevel, new GridBagConstraints(0, 3, 1, 1, 0, 0, GridBagConstraints.LINE_START, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
+        jTankChoose.add(mapListBox, new GridBagConstraints(1, 3, 1, 1, 0, 0, GridBagConstraints.LINE_START, 0, new Insets(0, 0, 0, 0), 0, 0));
+
+        jTankChoose.add(goGame, new GridBagConstraints(1, 4, 1, 1, 0, 0, GridBagConstraints.LINE_START, 0, new Insets(0, -50, 0, 0), 0, 0));
+        jTankChoose.add(record, new GridBagConstraints(1, 5, 1, 1, 0, 0, GridBagConstraints.LINE_START, 0, new Insets(0, -100, 0, 0), 0, 0));
+
+        goGame.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                notReplay = true;
+                frame.setFocusable(true);
+                selectObjects();
+                drawBF();
+                try {
+                    fos = new FileOutputStream(fileName);
+                    oos = new ObjectOutputStream(new BufferedOutputStream(fos));
+                } catch (IOException e1) {
+                    e1.printStackTrace();
+                }
+                recordActions.writeGameData(oos, mapLevel, firstAggressorIdx, secondAggressorIdx);
+                runTheGame();
+            }
+        });
+        return jTankChoose;
+    }
+
+    private void tanksCoordinates() {
+        firstAggressorLocation = battleField.getFirstAggressorLocation();
+        firstAggressorLocationX = Integer.parseInt(firstAggressorLocation.split("_")[1]);
+        firstAggressorLocationY = Integer.parseInt(firstAggressorLocation.split("_")[0]);
+
+        secondAggressorLocation = battleField.getSecondAggressorLocation();
+        secondAggressorLocationX = Integer.parseInt(secondAggressorLocation.split("_")[1]);
+        secondAggressorLocationY = Integer.parseInt(secondAggressorLocation.split("_")[0]);
+
+        defenderLocation = battleField.getDefenderLocation();
+        defenderLocationX = Integer.parseInt(defenderLocation.split("_")[1]);
+        defenderLocationY = Integer.parseInt(defenderLocation.split("_")[0]);
+    }
+
+    private void selectObjects() {
+        tanksList = new ArrayList<>();
+        bullets = new ArrayList<>();
+        battleField = new BattleField(image, mapLevel);
+        eagle = battleField.getEagleLocation();
+        secondAggressorPlayer = false;
+
+        tanksCoordinates();
+
+        defender = new T34(battleField, defenderLocationX, defenderLocationY, Direction.UP, image, "d1");
+
+        if(firstAggressorIdx == 0) {
+            firstAggressor = new BT7(battleField,
+                    firstAggressorLocationX, firstAggressorLocationY, Direction.DOWN, image, eagle, firstAggressorPlayer, "a1");
+        } else if(firstAggressorIdx == 1) {
+            firstAggressor = new Tiger(battleField,
+                    firstAggressorLocationX, firstAggressorLocationY, Direction.DOWN, image, defender, firstAggressorPlayer, "a1");
+        }
+
+        if(secondAggressorIdx == 0) {
+            secondAggressor = new BT7(battleField,
+                    secondAggressorLocationX, secondAggressorLocationY, Direction.DOWN, image, eagle, secondAggressorPlayer, "a2");
+        } else if(secondAggressorIdx == 1) {
+            secondAggressor = new Tiger(battleField,
+                    secondAggressorLocationX, secondAggressorLocationY, Direction.DOWN, image, defender, secondAggressorPlayer, "a2");
+        }
+
+        tanksList.add(defender);
+        tanksList.add(firstAggressor);
+        tanksList.add(secondAggressor);
+    }
+    private void drawBF(){
+        frame.getContentPane().removeAll();
+        frame.getContentPane().add(gamePanel());
+        frame.setFocusable(true);
+        frame.pack();
+    }
+
+    private void closeOrRepeat() {
+        frame.getContentPane().removeAll();
+        frame.getContentPane().add(gameOver());
+        frame.pack();
+        frame.repaint();
+    }
+
+    private void gameResult() {
+        frame.getContentPane().removeAll();
+        frame.getContentPane().add(gameOptions());
+        frame.pack();
+        frame.repaint();
+    }
+
+    private class RBListener implements ActionListener {
+        private int idx;
+        public RBListener(int idx) {
+            this.idx = idx;
+        }
+        @Override
+        public void actionPerformed(ActionEvent e) {
+
+            if(idx == 0) {
+               firstAggressorIdx = Integer.parseInt(e.getActionCommand());
+            } else {
+                secondAggressorIdx = Integer.parseInt(e.getActionCommand());
+            }
+        }
+    }
+
+    private void sleep(long timeout) {
+        try {
+            Thread.sleep(timeout);
+        } catch (InterruptedException ex) {
+            // ignore
+        }
+    }
+
+}
\ No newline at end of file
Index: src/gameRecord/FileOfRecord.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/gameRecord/FileOfRecord.java	(revision )
+++ src/gameRecord/FileOfRecord.java	(revision )
@@ -0,0 +1,18 @@
+package gameRecord;
+
+import tanks.Action;
+import tanks.Direction;
+
+import java.io.FileOutputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.List;
+
+/**
+ * Created by Byblik272 on 14/2/2016.
+ */
+public interface FileOfRecord extends Serializable {
+
+    void write(String s, ObjectOutputStream oos, Direction direction, Action action);
+    List read(String fileName);
+}
Index: src/objectsOnField/Brick.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/objectsOnField/Brick.java	(revision )
+++ src/objectsOnField/Brick.java	(revision )
@@ -0,0 +1,15 @@
+package objectsOnField;
+
+import java.awt.*;
+
+/**
+ * Created by Byblik272 on 2/12/2015.
+ */
+public class Brick extends AbstractObjectOnField {
+
+    public Brick(int x, int y, Image image) {
+        super(x, y, image);
+        numberInQueue = 4;
+    }
+
+}
Index: src/tanks/Direction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/tanks/Direction.java	(revision )
+++ src/tanks/Direction.java	(revision )
@@ -0,0 +1,27 @@
+package tanks;
+
+/**
+ * Created by Byblik272 on 18/11/2015.
+ */
+public enum Direction {
+
+    UP(0), DOWN(1), LEFT(2), RIGHT(3);
+
+    private int id;
+
+    Direction(int id) {
+        this.setId(id);
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public Direction getValue(int id) {
+        return Direction.values()[id];
+    }
+}
Index: src/tanks/Drawable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/tanks/Drawable.java	(revision )
+++ src/tanks/Drawable.java	(revision )
@@ -0,0 +1,12 @@
+package tanks;
+
+import java.awt.*;
+
+/**
+ * Created by Byblik272 on 23/11/2015.
+ */
+public interface Drawable {
+
+    void draw(Graphics g);
+
+}
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision )
+++ .idea/misc.xml	(revision )
@@ -0,0 +1,85 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="EntryPointsManager">
+    <entry_points version="2.0" />
+  </component>
+  <component name="MavenImportPreferences">
+    <option name="generalSettings">
+      <MavenGeneralSettings>
+        <option name="mavenHome" value="Bundled (Maven 3)" />
+      </MavenGeneralSettings>
+    </option>
+  </component>
+  <component name="ProjectInspectionProfilesVisibleTreeState">
+    <entry key="Project Default">
+      <profile-state>
+        <expanded-state>
+          <State>
+            <id />
+          </State>
+          <State>
+            <id>Android Lint</id>
+          </State>
+          <State>
+            <id>Class structureJava</id>
+          </State>
+          <State>
+            <id>Cloning issuesJava</id>
+          </State>
+          <State>
+            <id>Groovy</id>
+          </State>
+          <State>
+            <id>Initialization issuesJava</id>
+          </State>
+          <State>
+            <id>J2ME issuesJava</id>
+          </State>
+          <State>
+            <id>JUnit issuesJava</id>
+          </State>
+          <State>
+            <id>Java</id>
+          </State>
+          <State>
+            <id>Java language level migration aidsJava</id>
+          </State>
+          <State>
+            <id>JavaBeans issuesJava</id>
+          </State>
+          <State>
+            <id>Plugin DevKit</id>
+          </State>
+          <State>
+            <id>Potentially confusing code constructsGroovy</id>
+          </State>
+          <State>
+            <id>Security issuesJava</id>
+          </State>
+          <State>
+            <id>Serialization issuesJava</id>
+          </State>
+          <State>
+            <id>Threading issuesJava</id>
+          </State>
+          <State>
+            <id>toString() issuesJava</id>
+          </State>
+        </expanded-state>
+      </profile-state>
+    </entry>
+  </component>
+  <component name="ProjectLevelVcsManager" settingsEditedManually="false">
+    <OptionsSetting value="true" id="Add" />
+    <OptionsSetting value="true" id="Remove" />
+    <OptionsSetting value="true" id="Checkout" />
+    <OptionsSetting value="true" id="Update" />
+    <OptionsSetting value="true" id="Status" />
+    <OptionsSetting value="true" id="Edit" />
+    <ConfirmationsSetting value="0" id="Add" />
+    <ConfirmationsSetting value="0" id="Remove" />
+  </component>
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_7" default="false" assert-keyword="true" jdk-15="true" project-jdk-name="1.7" project-jdk-type="JavaSDK">
+    <output url="file://$PROJECT_DIR$/out" />
+  </component>
+</project>
\ No newline at end of file
Index: src/tanks/AbstractTank.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/tanks/AbstractTank.java	(revision )
+++ src/tanks/AbstractTank.java	(revision )
@@ -0,0 +1,404 @@
+package tanks;
+
+import action.ActionField;
+import objectsOnField.*;
+
+import java.awt.*;
+import java.awt.image.CropImageFilter;
+import java.awt.image.FilteredImageSource;
+import java.util.List;
+import java.util.Random;
+
+/**
+ * Created by Byblik272 on 18/11/2015.
+ */
+public abstract class AbstractTank implements Tank {
+
+
+    protected int speed = 20;
+
+    protected int x;
+    protected int y;
+
+    protected Color tankColor;
+    protected Color towerColor;
+
+    private boolean destroyed;
+
+    protected Direction direction;
+
+    protected Image image;
+    protected Image[] images;
+
+    protected BattleField bf;
+
+    protected boolean player;
+    private boolean goLeft;
+
+    protected String crewName;
+
+    protected Tank tankOpponent;
+    protected AbstractObjectOnField eagleOpponent;
+
+    protected Action action;
+    protected Action playerAction;
+
+    protected long recharge = 0;
+
+    public AbstractTank(BattleField bf, int x, int y, Direction direction, Image image, boolean player, String crewName) {
+        this.bf = bf;
+        this.x = x;
+        this.y = y;
+        this.image = image;
+        this.direction = direction;
+        this.destroyed = false;
+        this.player = player;
+        this.crewName = crewName;
+        playerAction = Action.NONE;
+    }
+
+    protected Action destroyOpponent(Tank opponent){
+
+        if(getX() == opponent.getX() && getY() > opponent.getY()) {
+            turn(Direction.UP);
+        } else
+        if(getX() == opponent.getX() && getY() < opponent.getY()) {
+            turn(Direction.DOWN);
+        } else
+        if(getX() > opponent.getX() && getY() == opponent.getY()) {
+            turn(Direction.LEFT);
+        } else
+        if(getX() < opponent.getX() && getY() == opponent.getY()) {
+            turn(Direction.RIGHT);
+        } else
+        if(Math.abs(getX() - opponent.getX()) < Math.abs(getY() - opponent.getY())) {
+            if(getX() > opponent.getX()) {
+               if(theQuadrantToTheLeft() instanceof Water) {
+                   turn(Direction.DOWN);
+                   if((theQuadrantBelow() instanceof Brick || theQuadrantBelow() instanceof Rock) && !theQuadrantBelow().isDestroyed()) {
+                       return Action.FIRE;
+                   } else {
+                       action = Action.MOVE;
+                   }
+               } else
+                    turn(Direction.LEFT);
+                    if((theQuadrantToTheLeft() instanceof Brick || theQuadrantToTheLeft() instanceof Rock) && !theQuadrantToTheLeft().isDestroyed()) {
+                        return Action.FIRE;
+                   } else {
+                        action = Action.MOVE;
+                    }
+            } else {
+                if(theQuadrantToTheRight() instanceof Water) {
+                    turn(Direction.DOWN);
+                    if((theQuadrantBelow() instanceof Brick || theQuadrantBelow() instanceof Rock) && !theQuadrantBelow().isDestroyed()) {
+                        return Action.FIRE;
+                    } else {
+                        action = Action.MOVE;
+                    }
+                } else {
+                    turn(Direction.RIGHT);
+                    if((theQuadrantToTheRight() instanceof Brick || theQuadrantToTheRight() instanceof Rock) && !theQuadrantToTheRight().isDestroyed()) {
+                        return Action.FIRE;
+                    } else {
+                        action = Action.MOVE;
+                    }
+                }
+            }
+        }else {
+            if(getY() > opponent.getY()) {
+                if(theQuadrantAbove() instanceof Water) {
+                    turn(Direction.RIGHT);
+                    if((theQuadrantToTheRight() instanceof Brick || theQuadrantToTheRight() instanceof Rock) && !theQuadrantToTheRight().isDestroyed()) {
+                        return Action.FIRE;
+                    } else {
+                        action = Action.MOVE;
+                    }
+                } else {
+                    turn(Direction.UP);
+                    if((theQuadrantAbove() instanceof Brick || theQuadrantAbove() instanceof Rock) && !theQuadrantAbove().isDestroyed()) {
+                        return Action.FIRE;
+                    } else {
+                        action = Action.MOVE;
+                    }
+                }
+            } else {
+                if(theQuadrantBelow() instanceof Water) {
+                    turn(Direction.RIGHT);
+                    if((theQuadrantToTheRight() instanceof Brick || theQuadrantToTheRight() instanceof Rock) && !theQuadrantToTheRight().isDestroyed()) {
+                        return Action.FIRE;
+                    } else {
+                        action = Action.MOVE;
+                    }
+                } else {
+                    turn(Direction.DOWN);
+                    if((theQuadrantBelow() instanceof Brick || theQuadrantBelow() instanceof Rock) && !theQuadrantBelow().isDestroyed()) {
+                        return Action.FIRE;
+                    } else {
+                        action = Action.MOVE;
+                    }
+                }
+            }
+        }
+
+        theLevelOfDifficulty();
+
+        return action;
+    }
+
+    private void theLevelOfDifficulty() {
+        if(new Random().nextInt(100) < 95) {
+            action = Action.NONE;
+        } else
+        if(new Random().nextInt(100) < 30) {
+            action = Action.MOVE;
+        } else
+        if(new Random().nextInt(100) < 70) {
+            action = Action.FIRE;
+        }
+    }
+
+    protected Action destroyEagle(List<Tank> tankList) {
+        if(getY() == bf.getEagleY()) {
+            if(getX() > bf.getEagleX()) {
+                turn(Direction.LEFT);
+                action = Action.FIRE;
+            } else {
+                turn(Direction.RIGHT);
+                action = Action.FIRE;
+            }
+        } else {
+                if(tankBelow(tankList) || (theQuadrantBelow() instanceof Brick && !theQuadrantBelow().isDestroyed())) {
+                    turn(Direction.DOWN);
+                    action = Action.FIRE;
+                } else {
+                    turn(Direction.DOWN);
+                    action = Action.MOVE;
+                }
+            if(getX() == 0 || theQuadrantToTheLeft() instanceof Rock || theQuadrantToTheLeft() instanceof Water) {
+                goLeft = false;
+            }
+            if(getX() == 512 || theQuadrantToTheRight() instanceof Rock || theQuadrantToTheRight() instanceof Water) {
+                goLeft = true;
+            }
+            if(theQuadrantBelow() instanceof Water || theQuadrantBelow() instanceof Rock) {
+                if(goLeft) {
+                    if (theQuadrantToTheLeft() instanceof Brick && !theQuadrantToTheLeft().isDestroyed() || tankLeft(tankList)) {
+                        turn(Direction.LEFT);
+                        action = Action.FIRE;
+                    } else {
+                        turn(Direction.LEFT);
+                        action = Action.MOVE;
+                    }
+                } else {
+                    if(theQuadrantToTheRight() instanceof Brick && !theQuadrantToTheRight().isDestroyed() || tankRight(tankList)) {
+                        turn(Direction.RIGHT);
+                        action = Action.FIRE;
+                    } else {
+                        turn(Direction.RIGHT);
+                        action = Action.MOVE;
+                    }
+                }
+            }
+        }
+        return action;
+    }
+
+    private AbstractObjectOnField theQuadrantBelow() {
+        return bf.scanQuadrant(getY() / bf.getLimitQuadrant() + 1, getX() / bf.getLimitQuadrant());
+    }
+
+    private AbstractObjectOnField theQuadrantAbove() {
+        return bf.scanQuadrant(getY() / bf.getLimitQuadrant() - 1, getX() / bf.getLimitQuadrant());
+    }
+
+    private AbstractObjectOnField theQuadrantToTheLeft() {
+        return bf.scanQuadrant(getY() / bf.getLimitQuadrant(), getX() / bf.getLimitQuadrant() - 1);
+    }
+
+    private AbstractObjectOnField theQuadrantToTheRight() {
+        return bf.scanQuadrant(getY() / bf.getLimitQuadrant(), getX() / bf.getLimitQuadrant() + 1);
+    }
+
+    private boolean tankBelow(List<Tank> tankList) {
+        for(Tank tank : tankList) {
+            if(tank != this &&(tank.getY() - getY() == bf.getLimitQuadrant()) && (tank.getX() - getX() == 0) && !tank.isDestroyed()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean tankRight(List<Tank> tankList) {
+        for(Tank tank : tankList) {
+            if(tank != this &&(tank.getY() - getY() == 0) && (tank.getX() - getX() == bf.getLimitQuadrant()) && !tank.isDestroyed()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private boolean tankLeft(List<Tank> tankList) {
+        for(Tank tank : tankList) {
+            if(tank != this &&(tank.getY() - getY() == 0) && (getX() - tank.getX() == bf.getLimitQuadrant()) && !tank.isDestroyed()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public Action getAction() {
+
+        Action currentAction = playerAction;
+
+        if(currentAction == Action.FIRE) {
+            return Action.FIRE;
+        } else {
+            if(currentAction.getId() == direction.getId()) {
+                return Action.MOVE;
+            } else {
+                if(currentAction == Action.NONE) {
+                    return Action.NONE;
+                } else {
+                    direction = direction.getValue(currentAction.getId());
+                    return Action.NONE;
+                }
+            }
+        }
+    }
+
+    @Override
+    public void turn(Direction direction) {
+        this.direction = direction;
+    }
+
+    @Override
+    public Bullet fire() {
+        int bulletX = -100;
+        int bulletY = -100;
+        if (direction == Direction.UP) {
+            bulletX = x + 25;
+            bulletY = y - 15;
+        } else if (direction == Direction.DOWN) {
+            bulletX = x + 25;
+            bulletY = y + 65;
+        } else if (direction == Direction.LEFT) {
+            bulletX = x - 15;
+            bulletY = y + 25;
+        } else if (direction == Direction.RIGHT) {
+            bulletX = x + 65;
+            bulletY = y + 25;
+        }
+        recharge = System.currentTimeMillis() + 1000;
+        return new Bullet(bulletX, bulletY, direction, this, image, getCrewName());
+
+    }
+
+    @Override
+    public boolean isDestroyed() {
+        return destroyed;
+    }
+
+    @Override
+    public void holdRecharge(long timeout) {
+        recharge = recharge + timeout;
+    }
+
+    @Override
+    public void destroy() {
+        destroyed = true;
+    }
+
+    @Override
+    public Direction getDirection() {
+        return direction;
+    }
+
+    @Override
+    public void setDirection(Direction direction) {
+        this.direction = direction;
+    }
+
+    @Override
+    public String getCrewName() {
+        return crewName;
+    }
+
+    @Override
+    public void setPlayerAction(Action playerAction) {
+        this.playerAction = playerAction;
+    }
+
+    @Override
+    public void updateX(int x) {
+        this.x += x;
+    }
+
+    @Override
+    public void updateY(int y) {
+        this.y += y;
+    }
+
+    @Override
+    public int getX() {
+        return x;
+    }
+
+    @Override
+    public int getY() {
+        return y;
+    }
+
+    @Override
+    public boolean isRecharge() {
+        return recharge < System.currentTimeMillis();
+    }
+
+    @Override
+    public void setX(int x) {
+        this.x = x;
+    }
+
+    @Override
+    public void setY(int y) {
+        this.y = y;
+    }
+
+    @Override
+    public int getSpeed() {
+        return speed;
+    }
+
+    @Override
+    public Image createImage(Image image, int x1, int y1, int x2, int y2) {
+        return Toolkit.getDefaultToolkit().createImage(new FilteredImageSource(image.getSource(), new CropImageFilter(x1, y1, x2, y2)));
+    }
+    @Override
+    public void draw(Graphics g) {
+        if (!destroyed) {
+            if(images != null) {
+                g.drawImage(images[getDirection().getId()], getX(), getY(), null);
+            }else {
+                g.setColor(tankColor);
+                g.fillRect(this.getX(), this.getY(), 64, 64);
+
+                g.setColor(towerColor);
+                if (this.getDirection() == Direction.UP) {
+                    g.fillRect(this.getX() + 20, this.getY(), 24, 34);
+
+                } else if (this.getDirection() == Direction.DOWN) {
+                    g.fillRect(this.getX() + 20, this.getY() + 30, 24, 34);
+
+                } else if (this.getDirection() == Direction.LEFT) {
+                    g.fillRect(this.getX(), this.getY() + 20, 34, 24);
+
+                } else {
+                    g.fillRect(this.getX() + 30, this.getY() + 20, 34, 24);
+                }
+                if(bf.scanQuadrant(getY() / 64, getX() / 64) instanceof Water) {
+                    bf.scanQuadrant(getY() / 64, getX() / 64).draw(g);
+                }
+            }
+        }
+    }
+}
Index: src/objectsOnField/Rock.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/objectsOnField/Rock.java	(revision )
+++ src/objectsOnField/Rock.java	(revision )
@@ -0,0 +1,15 @@
+package objectsOnField;
+
+import java.awt.*;
+
+/**
+ * Created by Byblik272 on 2/12/2015.
+ */
+public class Rock extends AbstractObjectOnField {
+
+    public Rock(int x, int y, Image image) {
+        super(x, y, image);
+        imageX = 8;
+        numberInQueue = 3;
+    }
+}
Index: src/tanks/Destroyable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/tanks/Destroyable.java	(revision )
+++ src/tanks/Destroyable.java	(revision )
@@ -0,0 +1,12 @@
+package tanks;
+
+/**
+ * Created by Byblik272 on 23/11/2015.
+ */
+public interface Destroyable {
+
+    void destroy();
+
+    boolean isDestroyed();
+
+}
Index: src/objectsOnField/Water.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/objectsOnField/Water.java	(revision )
+++ src/objectsOnField/Water.java	(revision )
@@ -0,0 +1,15 @@
+package objectsOnField;
+
+import java.awt.*;
+
+/**
+ * Created by Byblik272 on 2/12/2015.
+ */
+public class Water extends AbstractObjectOnField {
+
+    public Water(int x, int y, Image image) {
+        super(x, y, image);
+        color = new Color(0, 0, 255);
+        numberInQueue = 6;
+    }
+}
Index: src/tanks/Tank.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/tanks/Tank.java	(revision )
+++ src/tanks/Tank.java	(revision )
@@ -0,0 +1,43 @@
+package tanks;
+
+import java.awt.*;
+import java.util.List;
+
+public interface Tank extends Drawable, Destroyable {
+	
+    Action setUp(List<Tank> tankList);
+
+    Action getAction();
+
+    Bullet fire();
+
+    int getX();
+
+	int getY();
+
+    void setX(int x);
+
+    void setY(int y);
+
+    boolean isRecharge();
+
+    void holdRecharge(long recharge);
+	
+	Direction getDirection();
+
+	void updateX(int x);
+
+	void updateY(int y);
+
+	int getSpeed();
+
+    void setDirection(Direction direction);
+
+    void turn(Direction direction);
+
+    void setPlayerAction(Action playerAction);
+
+    String getCrewName();
+
+    Image createImage(Image image, int x1, int y1, int x2, int y2);
+}
Index: src/META-INF/MANIFEST.MF
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/META-INF/MANIFEST.MF	(revision )
+++ src/META-INF/MANIFEST.MF	(revision )
@@ -0,0 +1,3 @@
+Manifest-Version: 1.0
+Main-Class: run.Launcher
+
Index: src/objectsOnField/Void.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/objectsOnField/Void.java	(revision )
+++ src/objectsOnField/Void.java	(revision )
@@ -0,0 +1,14 @@
+package objectsOnField;
+
+import java.awt.*;
+
+/**
+ * Created by Byblik272 on 2/12/2015.
+ */
+public class Void extends AbstractObjectOnField {
+
+    public Void(int x, int y, Image image) {
+        super(x, y, image);
+        numberInQueue = 8;
+    }
+}
Index: .idea/encodings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/encodings.xml	(revision )
+++ .idea/encodings.xml	(revision )
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding">
+    <file url="PROJECT" charset="UTF-8" />
+  </component>
+</project>
\ No newline at end of file
Index: src/tanks/BT7.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/tanks/BT7.java	(revision )
+++ src/tanks/BT7.java	(revision )
@@ -0,0 +1,37 @@
+package tanks;
+
+import objectsOnField.AbstractObjectOnField;
+import objectsOnField.BattleField;
+
+import java.awt.*;
+import java.util.List;
+
+public class BT7 extends AbstractTank {
+	
+	public BT7(BattleField bf, int x, int y, Direction direction, Image image, AbstractObjectOnField opponent, boolean player, String crewName) {
+		super(bf, x, y, direction, image, player, crewName);
+		tankColor = new Color(255, 0, 0);
+		towerColor = new Color(0, 255, 0);
+        setImage();
+        eagleOpponent = opponent;
+	}
+
+    private void setImage() {
+        images = new Image[4];
+
+        for(int i = 0; i < images.length; i++) {
+            images[i] = createImage(image, 64 * i, 0, 64, 64);
+        }
+    }
+
+	@Override
+	public Action setUp(List<Tank> tankList) {
+        if(player) {
+            return getAction();
+        } else {
+
+            return destroyEagle(tankList);
+        }
+
+    }
+}
Index: src/objectsOnField/AbstractObjectOnField.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/objectsOnField/AbstractObjectOnField.java	(revision )
+++ src/objectsOnField/AbstractObjectOnField.java	(revision )
@@ -0,0 +1,75 @@
+package objectsOnField;
+
+import tanks.Destroyable;
+import tanks.Drawable;
+
+import java.awt.*;
+
+/**
+ * Created by Byblik272 on 2/12/2015.
+ */
+public abstract class AbstractObjectOnField implements Drawable, Destroyable {
+
+    private int x;
+    private int y;
+    private int objectBody = 64;
+    private int imageBasicCoordinate = 65;
+    private int differenceOfPixels = 2;
+    protected int numberInQueue;
+    protected int imageX;
+
+    private boolean isDestroyed = false;
+    protected Color color;
+    protected Image image;
+
+    public AbstractObjectOnField(int x, int y, Image image) {
+        this.x = x;
+        this.y = y;
+        this.image = image;
+    }
+
+    @Override
+    public void destroy() {
+        isDestroyed = true;
+    }
+
+    @Override
+    public void draw(Graphics g) {
+        if (!isDestroyed) {
+            if(image != null) {
+
+                g.drawImage(image, getX(), getY(), getX() + objectBody, getY() + objectBody,
+                        imageBasicCoordinate + objectBody * numberInQueue, imageBasicCoordinate,
+                        objectBody * (numberInQueue + differenceOfPixels), objectBody * differenceOfPixels, null);
+
+            } else {
+                g.setColor(this.color);
+                g.fillRect(this.getX(), this.getY(), objectBody, objectBody);
+            }
+        } else {
+            g.setColor(Color.BLACK);
+            g.fillRect(this.getX(), this.getY(), objectBody, objectBody);
+        }
+    }
+
+    public boolean isDestroyed() {
+        return isDestroyed;
+    }
+
+
+    public int getX() {
+        return x;
+    }
+
+    public void setX(int x) {
+        this.x = x;
+    }
+
+    public int getY() {
+        return y;
+    }
+
+    public void setY(int y) {
+        this.y = y;
+    }
+}
Index: src/objectsOnField/BattleField.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/objectsOnField/BattleField.java	(revision )
+++ src/objectsOnField/BattleField.java	(revision )
@@ -0,0 +1,159 @@
+package objectsOnField;
+
+import tanks.Drawable;
+
+import java.awt.*;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by Byblik272 on 18/11/2015.
+ */
+
+public class BattleField implements Drawable {
+
+    final boolean COLORED_MODE = false;
+
+    private final int BF_WIDTH = 576 + 16;
+    private final int BF_HEIGHT = 576 + 39;
+
+    private final int limitQuadrant = 64;
+
+    private final int minRiftField = 0;
+    private final int maxRiftField = 512;
+
+    public static final String BRICK = "B";
+    public static final String EAGLE = "E";
+    public static final String ROCK = "R";
+    public static final String WATER = "W";
+    public static final String SHRUB = "S";
+    public static final String VOID = "V";
+
+    private Image image;
+    private MapsOfBattleField map;
+
+    private int eagleV;
+    private int eagleH;
+
+    private String[][] battleField = new String[9][9];
+
+    public BattleField(Image image, int idx) {
+      this.image = image;
+        map = new MapsOfBattleField();
+        battleField = map.getMap(idx);
+        addObjectField();
+    }
+
+    private AbstractObjectOnField[][] objectOnFields = new AbstractObjectOnField[battleField.length][battleField[0].length];
+
+    private List<Integer> shrubsX = new ArrayList<>();
+    private List<Integer> shrubsY = new ArrayList<>();
+
+        public void addObjectField() {
+
+            for (int v = 0; v < battleField.length; v++) {
+                for (int h = 0; h < battleField[0].length; h++) {
+
+                    String obj = battleField[v][h];
+                    if (obj.equals(VOID)) {
+                        objectOnFields[v][h] = new Void(h * limitQuadrant, v * limitQuadrant, image);
+                    }
+                    if (obj.equals(BRICK)) {
+                        objectOnFields[v][h] = new Brick(h * limitQuadrant, v * limitQuadrant, image);
+                    }
+                    if (obj.equals(ROCK)) {
+                        objectOnFields[v][h] = new Rock(h * limitQuadrant, v * limitQuadrant, image);
+                    }
+                    if (obj.equals(WATER)) {
+                        objectOnFields[v][h] = new Water(h * limitQuadrant, v * limitQuadrant, image);
+                    }
+                    if (obj.equals(SHRUB)) {
+                        objectOnFields[v][h] = new Void(h * limitQuadrant, v * limitQuadrant, image);
+                        shrubsY.add(v * limitQuadrant);
+                        shrubsX.add(h * limitQuadrant);
+                    }
+                    if (obj.equals(EAGLE)) {
+                        objectOnFields[v][h] = new Eagle(h * limitQuadrant, v * limitQuadrant, image);
+                        eagleV = v;
+                        eagleH = h;
+                    }
+                }
+            }
+        }
+
+    public int getEagleX() {
+        return eagleH * limitQuadrant;
+    }
+
+    public int getEagleY() {
+        return eagleV * limitQuadrant;
+    }
+
+    public AbstractObjectOnField getEagleLocation() {
+        return objectOnFields[eagleV][eagleH];
+    }
+
+    public String getFirstAggressorLocation() {
+        return "0_0";
+    }
+
+    public String getSecondAggressorLocation() {
+        return "0_512";
+    }
+
+    public String getDefenderLocation() {
+        return "512_128";
+    }
+
+    public int getBF_WIDTH() {
+        return BF_WIDTH;
+    }
+
+    public int getBF_HEIGHT() {
+        return BF_HEIGHT;
+    }
+
+    public int getLimitQuadrant() {
+        return limitQuadrant;
+    }
+
+    public int getMinRiftField() {
+        return minRiftField;
+    }
+
+    public int getMaxRiftField() {
+        return maxRiftField;
+    }
+
+    public AbstractObjectOnField scanQuadrant(int v, int h) {
+        return objectOnFields[v][h];
+    }
+
+    public void destroyObject(int v, int h) {
+        objectOnFields[v][h].destroy();
+    }
+
+    public int getMapListSize() {
+        return map.getMapListSize();
+    }
+
+    @Override
+    public void draw(Graphics g) {
+
+        for (int v = 0; v < battleField.length; v++) {
+            for (int h = 0; h < battleField[0].length; h++) {
+                objectOnFields[v][h].draw(g);
+            }
+        }
+    }
+
+    public void drawShrubs(Graphics g) {
+
+        for(int i = 0; i < shrubsX.size(); i++) {
+            g.drawImage(image, shrubsX.get(i), shrubsY.get(i), shrubsX.get(i) + limitQuadrant, shrubsY.get(i) +limitQuadrant,
+                    65 + 64 * 5, 65, 64 * 7, 64 * 2, null);
+        }
+    }
+}
\ No newline at end of file
Index: .idea/.name
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/.name	(revision )
+++ .idea/.name	(revision )
@@ -0,0 +1,1 @@
+TanksGame
\ No newline at end of file
Index: TanksGame.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TanksGame.iml	(revision )
+++ TanksGame.iml	(revision )
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
\ No newline at end of file
Index: src/run/Launcher.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/run/Launcher.java	(revision )
+++ src/run/Launcher.java	(revision )
@@ -0,0 +1,13 @@
+package run;
+
+import action.ActionField;
+
+/**
+ * Created by Byblik272 on 18/11/2015.
+ */
+public class Launcher {
+    public static void main(String[] args) throws Exception {
+
+        new ActionField();
+    }
+}
Index: .idea/artifacts/TanksGame_jar.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/artifacts/TanksGame_jar.xml	(revision )
+++ .idea/artifacts/TanksGame_jar.xml	(revision )
@@ -0,0 +1,8 @@
+<component name="ArtifactManager">
+  <artifact type="jar" name="TanksGame:jar">
+    <output-path>$PROJECT_DIR$/out/artifacts/TanksGame_jar</output-path>
+    <root id="archive" name="TanksGame.jar">
+      <element id="module-output" name="TanksGame" />
+    </root>
+  </artifact>
+</component>
\ No newline at end of file
Index: .idea/uiDesigner.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/uiDesigner.xml	(revision )
+++ .idea/uiDesigner.xml	(revision )
@@ -0,0 +1,124 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Palette2">
+    <group name="Swing">
+      <item class="com.intellij.uiDesigner.HSpacer" tooltip-text="Horizontal Spacer" icon="/com/intellij/uiDesigner/icons/hspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="1" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="com.intellij.uiDesigner.VSpacer" tooltip-text="Vertical Spacer" icon="/com/intellij/uiDesigner/icons/vspacer.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="1" anchor="0" fill="2" />
+      </item>
+      <item class="javax.swing.JPanel" icon="/com/intellij/uiDesigner/icons/panel.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JScrollPane" icon="/com/intellij/uiDesigner/icons/scrollPane.png" removable="false" auto-create-binding="false" can-attach-label="true">
+        <default-constraints vsize-policy="7" hsize-policy="7" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JButton" icon="/com/intellij/uiDesigner/icons/button.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="0" fill="1" />
+        <initial-values>
+          <property name="text" value="Button" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JRadioButton" icon="/com/intellij/uiDesigner/icons/radioButton.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="RadioButton" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JCheckBox" icon="/com/intellij/uiDesigner/icons/checkBox.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="3" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="CheckBox" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JLabel" icon="/com/intellij/uiDesigner/icons/label.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="8" fill="0" />
+        <initial-values>
+          <property name="text" value="Label" />
+        </initial-values>
+      </item>
+      <item class="javax.swing.JTextField" icon="/com/intellij/uiDesigner/icons/textField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JPasswordField" icon="/com/intellij/uiDesigner/icons/passwordField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JFormattedTextField" icon="/com/intellij/uiDesigner/icons/formattedTextField.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1">
+          <preferred-size width="150" height="-1" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextArea" icon="/com/intellij/uiDesigner/icons/textArea.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTextPane" icon="/com/intellij/uiDesigner/icons/textPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JEditorPane" icon="/com/intellij/uiDesigner/icons/editorPane.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JComboBox" icon="/com/intellij/uiDesigner/icons/comboBox.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="2" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JTable" icon="/com/intellij/uiDesigner/icons/table.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JList" icon="/com/intellij/uiDesigner/icons/list.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="2" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTree" icon="/com/intellij/uiDesigner/icons/tree.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3">
+          <preferred-size width="150" height="50" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JTabbedPane" icon="/com/intellij/uiDesigner/icons/tabbedPane.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSplitPane" icon="/com/intellij/uiDesigner/icons/splitPane.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="3" hsize-policy="3" anchor="0" fill="3">
+          <preferred-size width="200" height="200" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JSpinner" icon="/com/intellij/uiDesigner/icons/spinner.png" removable="false" auto-create-binding="true" can-attach-label="true">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSlider" icon="/com/intellij/uiDesigner/icons/slider.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="8" fill="1" />
+      </item>
+      <item class="javax.swing.JSeparator" icon="/com/intellij/uiDesigner/icons/separator.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="6" anchor="0" fill="3" />
+      </item>
+      <item class="javax.swing.JProgressBar" icon="/com/intellij/uiDesigner/icons/progressbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JToolBar" icon="/com/intellij/uiDesigner/icons/toolbar.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="6" anchor="0" fill="1">
+          <preferred-size width="-1" height="20" />
+        </default-constraints>
+      </item>
+      <item class="javax.swing.JToolBar$Separator" icon="/com/intellij/uiDesigner/icons/toolbarSeparator.png" removable="false" auto-create-binding="false" can-attach-label="false">
+        <default-constraints vsize-policy="0" hsize-policy="0" anchor="0" fill="1" />
+      </item>
+      <item class="javax.swing.JScrollBar" icon="/com/intellij/uiDesigner/icons/scrollbar.png" removable="false" auto-create-binding="true" can-attach-label="false">
+        <default-constraints vsize-policy="6" hsize-policy="0" anchor="0" fill="2" />
+      </item>
+    </group>
+  </component>
+</project>
\ No newline at end of file
Index: src/tanks/Bullet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/tanks/Bullet.java	(revision )
+++ src/tanks/Bullet.java	(revision )
@@ -0,0 +1,113 @@
+package tanks;
+
+import java.awt.*;
+import java.awt.image.CropImageFilter;
+import java.awt.image.FilteredImageSource;
+
+/**
+ * Created by Byblik272 on 18/11/2015.
+ */
+
+public class Bullet implements Drawable, Destroyable {
+
+    private int x;
+    private int y;
+
+    private int Speed = 3;
+
+    private Direction direction;
+    private boolean destroyed;
+    private Tank tank;
+    private Image image;
+    private String crewName;
+
+    private Image[] images;
+
+    public Bullet(int x, int y, Direction direction, Tank tank, Image image, String crewName) {
+        this.x = x;
+        this.y = y;
+        this.direction = direction;
+        this.destroyed = false;
+        this.tank = tank;
+        this.image = image;
+        this.crewName = crewName;
+        setImage();
+    }
+    public Tank getTank() {
+        return tank;
+    }
+
+    public Direction getDirection() {
+        return direction;
+    }
+
+    public int getX() {
+        return x;
+    }
+
+    public void setX(int x) {
+        this.x = x;
+    }
+
+    public int getY() {
+        return y;
+    }
+
+    public String getCrewName() {
+        return crewName;
+    }
+
+    public void setY(int y) {
+        this.y = y;
+    }
+
+    public int getSpeed() {
+        return Speed;
+    }
+
+    public void updateX(int x) {
+        this.x += x;
+    }
+
+    public void updateY(int y) {
+        this.y += y;
+    }
+
+    public void destroy() {
+        destroyed = true;
+        x = -100;
+        y = -100;
+    }
+
+    @Override
+    public boolean isDestroyed() {
+        return destroyed;
+    }
+
+    private void setImage() {
+        images = new Image[4];
+
+        for(int i = 0; i < images.length; i++) {
+            images[i] = createImage(image, 64 * i, 128, 14, 14);
+        }
+    }
+
+    protected Image createImage(Image image, int x1, int y1, int x2, int y2) {
+        return Toolkit.getDefaultToolkit().createImage(new FilteredImageSource(image.getSource(), new CropImageFilter(x1, y1, x2, y2)));
+    }
+    @Override
+    public void draw(Graphics g) {
+        if(!destroyed) {
+            if(images != null) {
+                g.drawImage(images[getDirection().getId()], getX(), getY(), null);
+            } else {
+                g.setColor(new Color(255, 255, 0));
+                g.fillRect(this.getX(), this.getY(), 14, 14);
+            }
+        }
+    }
+
+
+
+}
+
Index: src/tanks/Action.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/tanks/Action.java	(revision )
+++ src/tanks/Action.java	(revision )
@@ -0,0 +1,21 @@
+package tanks;
+
+public enum Action {
+	
+	UP(0), DOWN(1), LEFT(2), RIGHT(3), NONE(4), MOVE(5), FIRE(6);
+
+    private int id;
+
+    Action(int id) {
+        this.setId(id);
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+}
Index: src/objectsOnField/MapsOfBattleField.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/objectsOnField/MapsOfBattleField.java	(revision )
+++ src/objectsOnField/MapsOfBattleField.java	(revision )
@@ -0,0 +1,71 @@
+package objectsOnField;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by Byblik272 on 24/3/2016.
+ */
+public class MapsOfBattleField {
+
+    List<String[][]> mapLis;
+
+    public MapsOfBattleField() {
+        mapLis = new ArrayList<>();
+        mapLis.add(map1);
+        mapLis.add(map2);
+        mapLis.add(map3);
+        mapLis.add(map4);
+    }
+    private String[][] map1 = {
+            {"V", "V", "R", "V", "B", "W", "W", "V", "V"},
+            {"V", "B", "W", "W", "V", "V", "R", "V", "V"},
+            {"B", "R", "V", "S", "S", "S", "V", "V", "V"},
+            {"V", "B", "S", "V", "V", "V", "S", "R", "R"},
+            {"R", "V", "S", "V", "V", "V", "S", "V", "V"},
+            {"B", "V", "S", "V", "V", "V", "S", "B", "V"},
+            {"B", "R", "V", "S", "S", "S", "V", "B", "V"},
+            {"B", "B", "V", "B", "B", "B", "V", "V", "V"},
+            {"V", "V", "V", "B", "E", "B", "V", "V", "V"}};
+
+    private String[][] map2 = {
+            {"V", "V", "R", "B", "R", "V", "W", "V", "V"},
+            {"V", "B", "V", "R", "V", "V", "V", "V", "V"},
+            {"V", "V", "V", "S", "B", "V", "R", "W", "W"},
+            {"V", "R", "V", "S", "W", "V", "V", "V", "V"},
+            {"V", "B", "V", "S", "W", "V", "V", "V", "B"},
+            {"B", "R", "V", "S", "W", "V", "V", "V", "B"},
+            {"B", "B", "V", "S", "S", "S", "V", "V", "V"},
+            {"R", "B", "V", "B", "B", "B", "V", "V", "B"},
+            {"V", "B", "V", "B", "E", "B", "V", "B", "B"}};
+
+    private String[][] map3 = {
+            {"V", "V", "V", "V", "B", "V", "V", "V", "V"},
+            {"B", "B", "R", "R", "B", "V", "V", "B", "B"},
+            {"V", "V", "V", "S", "S", "S", "V", "V", "B"},
+            {"V", "V", "V", "S", "W", "W", "V", "R", "R"},
+            {"V", "B", "V", "S", "S", "S", "V", "V", "B"},
+            {"B", "B", "V", "S", "W", "W", "V", "V", "B"},
+            {"B", "B", "V", "S", "S", "S", "V", "V", "V"},
+            {"R", "R", "V", "V", "B", "V", "V", "V", "V"},
+            {"V", "V", "V", "B", "E", "B", "V", "V", "V"}};
+
+    private String[][] map4 = {
+            {"V", "V", "R", "B", "R", "V", "V", "V", "V"},
+            {"V", "B", "V", "R", "V", "V", "V", "V", "V"},
+            {"W", "W", "V", "S", "S", "S", "R", "W", "W"},
+            {"W", "R", "V", "S", "V", "V", "V", "V", "V"},
+            {"V", "B", "V", "S", "V", "V", "V", "V", "B"},
+            {"B", "R", "V", "S", "V", "S", "V", "V", "B"},
+            {"B", "B", "V", "S", "S", "S", "W", "W", "V"},
+            {"R", "B", "V", "V", "B", "V", "V", "V", "B"},
+            {"V", "B", "V", "V", "E", "V", "V", "B", "B"}};
+
+    public String[][] getMap(int idx) {
+        return mapLis.get(idx);
+    }
+
+    public int getMapListSize() {
+        return mapLis.size();
+    }
+}
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/vcs.xml	(revision )
+++ .idea/vcs.xml	(revision )
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/compiler.xml	(revision )
+++ .idea/compiler.xml	(revision )
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CompilerConfiguration">
+    <resourceExtensions />
+    <wildcardResourcePatterns>
+      <entry name="!?*.java" />
+      <entry name="!?*.form" />
+      <entry name="!?*.class" />
+      <entry name="!?*.groovy" />
+      <entry name="!?*.scala" />
+      <entry name="!?*.flex" />
+      <entry name="!?*.kt" />
+      <entry name="!?*.clj" />
+      <entry name="!?*.aj" />
+    </wildcardResourcePatterns>
+    <annotationProcessing>
+      <profile default="true" name="Default" enabled="false">
+        <processorPath useClasspath="true" />
+      </profile>
+    </annotationProcessing>
+  </component>
+</project>
\ No newline at end of file
